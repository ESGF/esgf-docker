input {
    pipe {
        command => "cat ${ACCESS_LOG_FILE}"
    }
}
filter {
    # Extract components from the access log messages
    grok {
        match => {
            "message" => "%{IPORHOST:client_ip} - %{USER:user} \[%{HTTPDATE:request_time}\] \"%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}\" %{NUMBER:status_code} %{NUMBER:bytes_sent} \"%{DATA:referrer}\" \"%{DATA:user_agent}\" \"%{DATA:forwarded_for}\" \[%{NUMBER:request_duration}\]"
        }
        remove_field => ["message"]
    }
    # Drop any messages from the kube-probe
    if [user_agent] =~ "^kube-probe" {
        drop { }
    }
    # Only consider file downloads and OPeNDAP accesses
    if [request] !~ "^/thredds/(fileServer|dodsC)" {
        drop { }
    }
    # Replace the logstash timestamp with the timestamp from the request
    date {
        match => ["request_time", "dd/MMM/yyyy:HH:mm:ss Z"]
        remove_field => ["request_time"]
    }
    # Replace the client IP with the forwarded for IP if present
    if [forwarded_for] != "-" {
        mutate {
            rename => { "forwarded_for" => "client_ip" }
        }
    }
    # Get the country for the IP, dropping the IP in the process
    geoip {
        source => "client_ip"
        fields => ["country_code2"]
        remove_field => ["client_ip"]
    }
    mutate {
        # Replace the host with the specified external hostname
        replace => { "host" => "${EXTERNAL_HOSTNAME}" }
        # Move the country code to the top-level
        add_field => { "country_code" => "%{[geoip][country_code2]}" }
        # Remove any unrequired fields
        remove_field => ["command", "geoip", "user"]
    }
}
output {
    stdout {
        codec => rubydebug
    }
}
